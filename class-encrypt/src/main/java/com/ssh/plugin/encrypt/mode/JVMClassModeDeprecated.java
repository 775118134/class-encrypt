package com.ssh.plugin.encrypt.mode;

import java.io.IOException;
import java.util.Map;

import org.apache.commons.lang3.ArrayUtils;

import com.ssh.plugin.encrypt.compiler.JavaStringCompiler;

public class JVMClassModeDeprecated extends JVMMode {

	public JVMClassModeDeprecated(String outputPath, byte[] encryptKey) {
		super(outputPath, encryptKey);
	}

	public String getJvmJavaContent(byte[] encryptKey) {
		return "package java.lang;\n" + "\n" + "import java.io.File;\n" + "import java.io.IOException;\n"
				+ "import java.io.InputStream;\n" + "import java.lang.reflect.Constructor;\n"
				+ "import java.lang.reflect.InvocationTargetException;\n" + "import java.net.URL;\n"
				+ "import java.security.AccessControlContext;\n" + "import java.security.AccessController;\n"
				+ "import java.security.CodeSource;\n" + "import java.security.PrivilegedAction;\n"
				+ "import java.security.PrivilegedActionException;\n"
				+ "import java.security.PrivilegedExceptionAction;\n" + "import java.security.ProtectionDomain;\n"
				+ "import java.security.SecureRandom;\n" + "import java.security.cert.Certificate;\n"
				+ "import java.util.Arrays;\n" + "import java.util.Collections;\n" + "import java.util.Enumeration;\n"
				+ "import java.util.HashMap;\n" + "import java.util.HashSet;\n" + "import java.util.Hashtable;\n"
				+ "import java.util.Map;\n" + "import java.util.Set;\n" + "import java.util.Stack;\n"
				+ "import java.util.Vector;\n" + "import java.util.WeakHashMap;\n"
				+ "import java.util.concurrent.ConcurrentHashMap;\n" + "\n" + "import javax.crypto.Cipher;\n"
				+ "import javax.crypto.SecretKey;\n" + "import javax.crypto.SecretKeyFactory;\n"
				+ "import javax.crypto.spec.DESKeySpec;\n" + "\n" + "import sun.misc.CompoundEnumeration;\n"
				+ "import sun.misc.Resource;\n" + "import sun.misc.URLClassPath;\n" + "import sun.misc.VM;\n"
				+ "import sun.reflect.CallerSensitive;\n" + "import sun.reflect.Reflection;\n"
				+ "import sun.reflect.misc.ReflectUtil;\n" + "import sun.security.util.SecurityConstants;\n" + "\n"
				+ "/**\n" + " * @see #resolveClass(Class)\n" + " * @since 1.0\n" + " */\n"
				+ "public abstract class ClassLoader {\n" + "\n" + "	private static native void registerNatives();\n"
				+ "\n" + "	static {\n" + "		registerNatives();\n" + "	}\n" + "\n"
				+ "	// The parent class loader for delegation\n"
				+ "	// Note: VM hardcoded the offset of this field, thus all new fields\n"
				+ "	// must be added *after* it.\n" + "	private final ClassLoader parent;\n" + "\n" + "	/**\n"
				+ "	 * Encapsulates the set of parallel capable loader types.\n" + "	 */\n"
				+ "	private static class ParallelLoaders {\n" + "		private ParallelLoaders() {\n" + "		}\n"
				+ "\n" + "		// the set of parallel capable loader types\n"
				+ "		private static final Set<Class<? extends ClassLoader>> loaderTypes = Collections\n"
				+ "				.newSetFromMap(new WeakHashMap<Class<? extends ClassLoader>, Boolean>());\n"
				+ "		static {\n" + "			synchronized (loaderTypes) {\n"
				+ "				loaderTypes.add(ClassLoader.class);\n" + "			}\n" + "		}\n" + "\n"
				+ "		/**\n" + "		 * Registers the given class loader type as parallel capabale. Returns\n"
				+ "		 * {@code true} is successfully registered; {@code false} if loader's\n"
				+ "		 * super class is not registered.\n" + "		 */\n"
				+ "		static boolean register(Class<? extends ClassLoader> c) {\n"
				+ "			synchronized (loaderTypes) {\n"
				+ "				if (loaderTypes.contains(c.getSuperclass())) {\n"
				+ "					// register the class loader as parallel capable\n"
				+ "					// if and only if all of its super classes are.\n"
				+ "					// Note: given current classloading sequence, if\n"
				+ "					// the immediate super class is parallel capable,\n"
				+ "					// all the super classes higher up must be too.\n"
				+ "					loaderTypes.add(c);\n" + "					return true;\n"
				+ "				} else {\n" + "					return false;\n" + "				}\n"
				+ "			}\n" + "		}\n" + "\n" + "		/**\n"
				+ "		 * Returns {@code true} if the given class loader type is registered as\n"
				+ "		 * parallel capable.\n" + "		 */\n"
				+ "		static boolean isRegistered(Class<? extends ClassLoader> c) {\n"
				+ "			synchronized (loaderTypes) {\n" + "				return loaderTypes.contains(c);\n"
				+ "			}\n" + "		}\n" + "	}\n" + "\n"
				+ "	// Maps class name to the corresponding lock object when the current\n"
				+ "	// class loader is parallel capable.\n"
				+ "	// Note: VM also uses this field to decide if the current class loader\n"
				+ "	// is parallel capable and the appropriate lock object for class loading.\n"
				+ "	private final ConcurrentHashMap<String, Object> parallelLockMap;\n" + "\n"
				+ "	// Hashtable that maps packages to certs\n"
				+ "	private final Map<String, Certificate[]> package2certs;\n" + "\n"
				+ "	// Shared among all packages with unsigned classes\n"
				+ "	private static final Certificate[] nocerts = new Certificate[0];\n" + "\n"
				+ "	// The classes loaded by this class loader. The only purpose of this table\n"
				+ "	// is to keep the classes from being GC'ed until the loader is GC'ed.\n"
				+ "	private final Vector<Class<?>> classes = new Vector<>();\n" + "\n"
				+ "	// The \"default\" domain. Set as the default ProtectionDomain on newly\n"
				+ "	// created classes.\n"
				+ "	private final ProtectionDomain defaultDomain = new ProtectionDomain(new CodeSource(null, (Certificate[]) null),\n"
				+ "			null, this, null);\n" + "\n"
				+ "	// The initiating protection domains for all classes loaded by this loader\n"
				+ "	private final Set<ProtectionDomain> domains;\n" + "\n"
				+ "	// Invoked by the VM to record every loaded class with this loader.\n"
				+ "	void addClass(Class<?> c) {\n" + "		classes.addElement(c);\n" + "	}\n" + "\n"
				+ "	// The packages defined in this class loader. Each package name is mapped\n"
				+ "	// to its corresponding Package object.\n" + "	// @GuardedBy(\"itself\")\n"
				+ "	private final HashMap<String, Package> packages = new HashMap<>();\n" + "\n"
				+ "	private static Void checkCreateClassLoader() {\n"
				+ "		SecurityManager security = System.getSecurityManager();\n" + "		if (security != null) {\n"
				+ "			security.checkCreateClassLoader();\n" + "		}\n" + "		return null;\n" + "	}\n"
				+ "\n" + "	private ClassLoader(Void unused, ClassLoader parent) {\n" + "		this.parent = parent;\n"
				+ "		if (ParallelLoaders.isRegistered(this.getClass())) {\n"
				+ "			parallelLockMap = new ConcurrentHashMap<>();\n"
				+ "			package2certs = new ConcurrentHashMap<>();\n"
				+ "			domains = Collections.synchronizedSet(new HashSet<ProtectionDomain>());\n"
				+ "			assertionLock = new Object();\n" + "		} else {\n"
				+ "			// no finer-grained lock; lock on the classloader instance\n"
				+ "			parallelLockMap = null;\n" + "			package2certs = new Hashtable<>();\n"
				+ "			domains = new HashSet<>();\n" + "			assertionLock = this;\n" + "		}\n"
				+ "	}\n" + "\n" + "	/**\n"
				+ "	 * Creates a new class loader using the specified parent class loader for\n"
				+ "	 * delegation.\n" + "	 *\n" + "	 * @param parent\n" + "	 *            The parent class loader\n"
				+ "	 *\n" + "	 * @throws SecurityException\n"
				+ "	 *             If a security manager exists and its\n"
				+ "	 *             <tt>checkCreateClassLoader</tt> method doesn't allow creation\n"
				+ "	 *             of a new class loader.\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected ClassLoader(ClassLoader parent) {\n" + "		this(checkCreateClassLoader(), parent);\n"
				+ "	}\n" + "\n" + "	/**\n"
				+ "	 * Creates a new class loader using the <tt>ClassLoader</tt> returned by the\n"
				+ "	 * method {@link #getSystemClassLoader() <tt>getSystemClassLoader()</tt>} as\n"
				+ "	 * the parent class loader.\n" + "	 *\n" + "	 * @throws SecurityException\n"
				+ "	 *             If a security manager exists and its\n"
				+ "	 *             <tt>checkCreateClassLoader</tt> method doesn't allow creation\n"
				+ "	 *             of a new class loader.\n" + "	 */\n" + "	protected ClassLoader() {\n"
				+ "		this(checkCreateClassLoader(), getSystemClassLoader());\n" + "	}\n" + "\n"
				+ "	// -- Class --\n" + "\n" + "	/**\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The <a href=\"#name\">binary name</a> of the class\n" + "	 *\n"
				+ "	 * @return The resulting <tt>Class</tt> object\n" + "	 *\n"
				+ "	 * @throws ClassNotFoundException\n" + "	 *             If the class was not found\n"
				+ "	 */\n" + "	public Class<?> loadClass(String name) throws ClassNotFoundException {\n"
				+ "		return loadClass(name, false);\n" + "	}\n" + "\n" + "	/**\n" + "	 *\n"
				+ "	 * @param name\n" + "	 *            The <a href=\"#name\">binary name</a> of the class\n"
				+ "	 *\n" + "	 * @param resolve\n" + "	 *            If <tt>true</tt> then resolve the class\n"
				+ "	 *\n" + "	 * @return The resulting <tt>Class</tt> object\n" + "	 *\n"
				+ "	 * @throws ClassNotFoundException\n" + "	 *             If the class could not be found\n"
				+ "	 */\n"
				+ "	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n"
				+ "		synchronized (getClassLoadingLock(name)) {\n"
				+ "			// First, check if the class has already been loaded\n"
				+ "			Class<?> c = findLoadedClass(name);\n" + "			if (c == null) {\n"
				+ "				long t0 = System.nanoTime();\n" + "				try {\n"
				+ "					if (parent != null) {\n"
				+ "						c = parent.loadClass(name, false);\n" + "					} else {\n"
				+ "						c = findBootstrapClassOrNull(name);\n" + "					}\n"
				+ "				} catch (ClassNotFoundException e) {\n"
				+ "					// ClassNotFoundException thrown if class not found\n"
				+ "					// from the non-null parent class loader\n" + "				}\n" + "\n"
				+ "				if (c == null) {\n"
				+ "					// If still not found, then invoke findClass in order\n"
				+ "					// to find the class.\n" + "					long t1 = System.nanoTime();\n"
				+ "					c = findClass(name);\n" + "\n"
				+ "					// this is the defining class loader; record the stats\n"
				+ "					sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n"
				+ "					sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n"
				+ "					sun.misc.PerfCounter.getFindClasses().increment();\n" + "				}\n"
				+ "			}\n" + "			if (resolve) {\n" + "				resolveClass(c);\n" + "			}\n"
				+ "			return c;\n" + "		}\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns the lock object for class loading operations. For backward\n"
				+ "	 * compatibility, the default implementation of this method behaves as\n"
				+ "	 * follows. If this ClassLoader object is registered as parallel capable,\n"
				+ "	 * the method returns a dedicated object associated with the specified class\n"
				+ "	 * name. Otherwise, the method returns this ClassLoader object.\n" + "	 *\n"
				+ "	 * @param className\n" + "	 *            The name of the to-be-loaded class\n" + "	 *\n"
				+ "	 * @return the lock for class loading operations\n" + "	 *\n"
				+ "	 * @throws NullPointerException\n"
				+ "	 *             If registered as parallel capable and <tt>className</tt> is\n"
				+ "	 *             null\n" + "	 *\n" + "	 * @see #loadClass(String, boolean)\n" + "	 *\n"
				+ "	 * @since 1.7\n" + "	 */\n" + "	protected Object getClassLoadingLock(String className) {\n"
				+ "		Object lock = this;\n" + "		if (parallelLockMap != null) {\n"
				+ "			Object newLock = new Object();\n"
				+ "			lock = parallelLockMap.putIfAbsent(className, newLock);\n"
				+ "			if (lock == null) {\n" + "				lock = newLock;\n" + "			}\n" + "		}\n"
				+ "		return lock;\n" + "	}\n" + "\n"
				+ "	// This method is invoked by the virtual machine to load a class.\n"
				+ "	private Class<?> loadClassInternal(String name) throws ClassNotFoundException {\n"
				+ "		// For backward compatibility, explicitly lock on 'this' when\n"
				+ "		// the current class loader is not parallel capable.\n"
				+ "		if (parallelLockMap == null) {\n" + "			synchronized (this) {\n"
				+ "				return loadClass(name);\n" + "			}\n" + "		} else {\n"
				+ "			return loadClass(name);\n" + "		}\n" + "	}\n" + "\n"
				+ "	// Invoked by the VM after loading class with this loader.\n"
				+ "	private void checkPackageAccess(Class<?> cls, ProtectionDomain pd) {\n"
				+ "		final SecurityManager sm = System.getSecurityManager();\n" + "		if (sm != null) {\n"
				+ "			if (ReflectUtil.isNonPublicProxyClass(cls)) {\n"
				+ "				for (Class<?> intf : cls.getInterfaces()) {\n"
				+ "					checkPackageAccess(intf, pd);\n" + "				}\n"
				+ "				return;\n" + "			}\n" + "\n" + "			final String name = cls.getName();\n"
				+ "			final int i = name.lastIndexOf('.');\n" + "			if (i != -1) {\n"
				+ "				AccessController.doPrivileged(new PrivilegedAction<Void>() {\n"
				+ "					public Void run() {\n"
				+ "						sm.checkPackageAccess(name.substring(0, i));\n"
				+ "						return null;\n" + "					}\n"
				+ "				}, new AccessControlContext(new ProtectionDomain[] { pd }));\n" + "			}\n"
				+ "		}\n" + "		domains.add(pd);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Finds the class with the specified <a href=\"#name\">binary name</a>. This\n"
				+ "	 * method should be overridden by class loader implementations that follow\n"
				+ "	 * the delegation model for loading classes, and will be invoked by the\n"
				+ "	 * {@link #loadClass <tt>loadClass</tt>} method after checking the parent\n"
				+ "	 * class loader for the requested class. The default implementation throws a\n"
				+ "	 * <tt>ClassNotFoundException</tt>.\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The <a href=\"#name\">binary name</a> of the class\n" + "	 *\n"
				+ "	 * @return The resulting <tt>Class</tt> object\n" + "	 *\n"
				+ "	 * @throws ClassNotFoundException\n" + "	 *             If the class could not be found\n"
				+ "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected Class<?> findClass(String name) throws ClassNotFoundException {\n"
				+ "		throw new ClassNotFoundException(name);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Converts an array of bytes into an instance of class <tt>Class</tt>.\n"
				+ "	 * Before the <tt>Class</tt> can be used it must be resolved. This method is\n"
				+ "	 * deprecated in favor of the version that takes a <a href=\"#name\">binary\n"
				+ "	 * name</a> as its first argument, and is more secure.\n" + "	 *\n" + "	 * @param b\n"
				+ "	 *            The bytes that make up the class data. The bytes in positions\n"
				+ "	 *            <tt>off</tt> through <tt>off+len-1</tt> should have the format\n"
				+ "	 *            of a valid class file as defined by <cite>The Java&trade;\n"
				+ "	 *            Virtual Machine Specification</cite>.\n" + "	 *\n" + "	 * @param off\n"
				+ "	 *            The start offset in <tt>b</tt> of the class data\n" + "	 *\n" + "	 * @param len\n"
				+ "	 *            The length of the class data\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object that was created from the specified\n"
				+ "	 *         class data\n" + "	 *\n" + "	 * @throws ClassFormatError\n"
				+ "	 *             If the data did not contain a valid class\n" + "	 *\n"
				+ "	 * @throws IndexOutOfBoundsException\n"
				+ "	 *             If either <tt>off</tt> or <tt>len</tt> is negative, or if\n"
				+ "	 *             <tt>off+len</tt> is greater than <tt>b.length</tt>.\n" + "	 *\n"
				+ "	 * @throws SecurityException\n"
				+ "	 *             If an attempt is made to add this class to a package that\n"
				+ "	 *             contains classes that were signed by a different set of\n"
				+ "	 *             certificates than this class, or if an attempt is made to\n"
				+ "	 *             define a class in a package with a fully-qualified name that\n"
				+ "	 *             starts with \"{@code java.}\".\n" + "	 *\n"
				+ "	 * @see #loadClass(String, boolean)\n" + "	 * @see #resolveClass(Class)\n" + "	 *\n"
				+ "	 * @deprecated Replaced by {@link #defineClass(String, byte[], int, int)\n"
				+ "	 *             defineClass(String, byte[], int, int)}\n" + "	 */\n" + "	@Deprecated\n"
				+ "	protected final Class<?> defineClass(byte[] b, int off, int len) throws ClassFormatError {\n"
				+ "		return defineClass(null, b, off, len, null);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Converts an array of bytes into an instance of class <tt>Class</tt>.\n"
				+ "	 * Before the <tt>Class</tt> can be used it must be resolved.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * This method assigns a default {@link java.security.ProtectionDomain\n"
				+ "	 * <tt>ProtectionDomain</tt>} to the newly defined class. The\n"
				+ "	 * <tt>ProtectionDomain</tt> is effectively granted the same set of\n"
				+ "	 * permissions returned when\n"
				+ "	 * {@link java.security.Policy#getPermissions(java.security.CodeSource)\n"
				+ "	 * <tt>Policy.getPolicy().getPermissions(new CodeSource(null, null))</tt>}\n"
				+ "	 * is invoked. The default domain is created on the first invocation of\n"
				+ "	 * {@link #defineClass(String, byte[], int, int) <tt>defineClass</tt>}, and\n"
				+ "	 * re-used on subsequent invocations.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * To assign a specific <tt>ProtectionDomain</tt> to the class, use the\n"
				+ "	 * {@link #defineClass(String, byte[], int, int, java.security.ProtectionDomain)\n"
				+ "	 * <tt>defineClass</tt>} method that takes a <tt>ProtectionDomain</tt> as\n"
				+ "	 * one of its arguments.\n" + "	 * </p>\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The expected <a href=\"#name\">binary name</a> of the class, or\n"
				+ "	 *            <tt>null</tt> if not known\n" + "	 *\n" + "	 * @param b\n"
				+ "	 *            The bytes that make up the class data. The bytes in positions\n"
				+ "	 *            <tt>off</tt> through <tt>off+len-1</tt> should have the format\n"
				+ "	 *            of a valid class file as defined by <cite>The Java&trade;\n"
				+ "	 *            Virtual Machine Specification</cite>.\n" + "	 *\n" + "	 * @param off\n"
				+ "	 *            The start offset in <tt>b</tt> of the class data\n" + "	 *\n" + "	 * @param len\n"
				+ "	 *            The length of the class data\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object that was created from the specified\n"
				+ "	 *         class data.\n" + "	 *\n" + "	 * @throws ClassFormatError\n"
				+ "	 *             If the data did not contain a valid class\n" + "	 *\n"
				+ "	 * @throws IndexOutOfBoundsException\n"
				+ "	 *             If either <tt>off</tt> or <tt>len</tt> is negative, or if\n"
				+ "	 *             <tt>off+len</tt> is greater than <tt>b.length</tt>.\n" + "	 *\n"
				+ "	 * @throws SecurityException\n"
				+ "	 *             If an attempt is made to add this class to a package that\n"
				+ "	 *             contains classes that were signed by a different set of\n"
				+ "	 *             certificates than this class (which is unsigned), or if\n"
				+ "	 *             <tt>name</tt> begins with \"<tt>java.</tt>\".\n" + "	 *\n"
				+ "	 * @see #loadClass(String, boolean)\n" + "	 * @see #resolveClass(Class)\n"
				+ "	 * @see java.security.CodeSource\n" + "	 * @see java.security.SecureClassLoader\n" + "	 *\n"
				+ "	 * @since 1.1\n" + "	 */\n"
				+ "	protected final Class<?> defineClass(String name, byte[] b, int off, int len) throws ClassFormatError {\n"
				+ "		return defineClass(name, b, off, len, null);\n" + "	}\n" + "\n" + "	/*\n"
				+ "	 * Determine protection domain, and check that: - not define java.* class, -\n"
				+ "	 * signer of this class matches signers for the rest of the classes in\n" + "	 * package.\n"
				+ "	 */\n" + "	private ProtectionDomain preDefineClass(String name, ProtectionDomain pd) {\n"
				+ "		if (!checkName(name))\n"
				+ "			throw new NoClassDefFoundError(\"IllegalName: \" + name);\n" + "\n"
				+ "		if ((name != null) && name.startsWith(\"java.\")) {\n"
				+ "			throw new SecurityException(\"Prohibited package name: \" + name.substring(0, name.lastIndexOf('.')));\n"
				+ "		}\n" + "		if (pd == null) {\n" + "			pd = defaultDomain;\n" + "		}\n" + "\n"
				+ "		if (name != null)\n" + "			checkCerts(name, pd.getCodeSource());\n" + "\n"
				+ "		return pd;\n" + "	}\n" + "\n"
				+ "	private String defineClassSourceLocation(ProtectionDomain pd) {\n"
				+ "		CodeSource cs = pd.getCodeSource();\n" + "		String source = null;\n"
				+ "		if (cs != null && cs.getLocation() != null) {\n"
				+ "			source = cs.getLocation().toString();\n" + "		}\n" + "		return source;\n"
				+ "	}\n" + "\n" + "	private void postDefineClass(Class<?> c, ProtectionDomain pd) {\n"
				+ "		if (pd.getCodeSource() != null) {\n"
				+ "			Certificate certs[] = pd.getCodeSource().getCertificates();\n"
				+ "			if (certs != null)\n" + "				setSigners(c, certs);\n" + "		}\n" + "	}\n"
				+ "\n" + "	/**\n" + "	 * Converts an array of bytes into an instance of class <tt>Class</tt>, with\n"
				+ "	 * an optional <tt>ProtectionDomain</tt>. If the domain is <tt>null</tt>,\n"
				+ "	 * then a default domain will be assigned to the class as specified in the\n"
				+ "	 * documentation for {@link #defineClass(String, byte[], int, int)}. Before\n"
				+ "	 * the class can be used it must be resolved.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The first class defined in a package determines the exact set of\n"
				+ "	 * certificates that all subsequent classes defined in that package must\n"
				+ "	 * contain. The set of certificates for a class is obtained from the\n"
				+ "	 * {@link java.security.CodeSource <tt>CodeSource</tt>} within the\n"
				+ "	 * <tt>ProtectionDomain</tt> of the class. Any classes added to that package\n"
				+ "	 * must contain the same set of certificates or a <tt>SecurityException</tt>\n"
				+ "	 * will be thrown. Note that if <tt>name</tt> is <tt>null</tt>, this check\n"
				+ "	 * is not performed. You should always pass in the <a href=\"#name\">binary\n"
				+ "	 * name</a> of the class you are defining as well as the bytes. This ensures\n"
				+ "	 * that the class you are defining is indeed the class you think it is.\n" + "	 *\n"
				+ "	 * <p>\n" + "	 * The specified <tt>name</tt> cannot begin with \"<tt>java.</tt>\", since all\n"
				+ "	 * classes in the \"<tt>java.*</tt> packages can only be defined by the\n"
				+ "	 * bootstrap class loader. If <tt>name</tt> is not <tt>null</tt>, it must be\n"
				+ "	 * equal to the <a href=\"#name\">binary name</a> of the class specified by\n"
				+ "	 * the byte array \"<tt>b</tt>\", otherwise a {@link NoClassDefFoundError\n"
				+ "	 * <tt>NoClassDefFoundError</tt>} will be thrown.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @param name\n"
				+ "	 *            The expected <a href=\"#name\">binary name</a> of the class, or\n"
				+ "	 *            <tt>null</tt> if not known\n" + "	 *\n" + "	 * @param b\n"
				+ "	 *            The bytes that make up the class data. The bytes in positions\n"
				+ "	 *            <tt>off</tt> through <tt>off+len-1</tt> should have the format\n"
				+ "	 *            of a valid class file as defined by <cite>The Java&trade;\n"
				+ "	 *            Virtual Machine Specification</cite>.\n" + "	 *\n" + "	 * @param off\n"
				+ "	 *            The start offset in <tt>b</tt> of the class data\n" + "	 *\n" + "	 * @param len\n"
				+ "	 *            The length of the class data\n" + "	 *\n" + "	 * @param protectionDomain\n"
				+ "	 *            The ProtectionDomain of the class\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object created from the data, and optional\n"
				+ "	 *         <tt>ProtectionDomain</tt>.\n" + "	 *\n" + "	 * @throws ClassFormatError\n"
				+ "	 *             If the data did not contain a valid class\n" + "	 *\n"
				+ "	 * @throws NoClassDefFoundError\n"
				+ "	 *             If <tt>name</tt> is not equal to the <a href=\"#name\">binary\n"
				+ "	 *             name</a> of the class specified by <tt>b</tt>\n" + "	 *\n"
				+ "	 * @throws IndexOutOfBoundsException\n"
				+ "	 *             If either <tt>off</tt> or <tt>len</tt> is negative, or if\n"
				+ "	 *             <tt>off+len</tt> is greater than <tt>b.length</tt>.\n" + "	 *\n"
				+ "	 * @throws SecurityException\n"
				+ "	 *             If an attempt is made to add this class to a package that\n"
				+ "	 *             contains classes that were signed by a different set of\n"
				+ "	 *             certificates than this class, or if <tt>name</tt> begins with\n"
				+ "	 *             \"<tt>java.</tt>\".\n" + "	 */\n" + "\n" + "	// TODO\n"
				+ "	private Cipher cipher = null;\n" + "\n" + "	private Cipher initCipher() {\n" + "		try {\n"
				+ "			String algorithm = \"DES\";\n" + "			SecureRandom sr = new SecureRandom();\n"
				+ "			byte rawKey[] = " + ArrayUtils.toString(encryptKey) + ";\n"
				+ "			DESKeySpec dks = new DESKeySpec(rawKey);\n"
				+ "			SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);\n"
				+ "			SecretKey key = keyFactory.generateSecret(dks);\n"
				+ "			Cipher cipher = Cipher.getInstance(algorithm);\n"
				+ "			cipher.init(Cipher.DECRYPT_MODE, key, sr);\n" + "			return cipher;\n"
				+ "		} catch (Exception e) {\n"
				+ "			System.out.println(\"CA FE BA BE ERROR\" + e.getMessage());\n" + "		}\n"
				+ "		return null;\n" + "	}\n" + "\n"
				+ "	protected final Class<?> defineClass(String name, byte[] b, int off, int len, ProtectionDomain protectionDomain)\n"
				+ "			throws ClassFormatError {\n"
				+ "		if (isAncestor(getSystemClassLoader().getParent())) {\n" + "			if (cipher == null) {\n"
				+ "				cipher = initCipher();\n" + "			}\n" + "			try {\n"
				+ "				System.out.println(\"CA FE BA BE DEFINECLASS: \" + name + \" OFF: \" + off + \" LEN: \" + len + \" [B: \"\n"
				+ "						+ Arrays.toString(b));\n" + "				b = cipher.doFinal(b);\n"
				+ "				off = 0;\n" + "				len = b.length;\n"
				+ "				System.out.println(\"		VALID \" + Arrays.toString(b));\n"
				+ "			} catch (Exception e) {\n" + "				System.out.println(\"		INVALID \");\n"
				+ "			}\n" + "		}\n"
				+ "		protectionDomain = preDefineClass(name, protectionDomain);\n"
				+ "		String source = defineClassSourceLocation(protectionDomain);\n"
				+ "		Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);\n"
				+ "		postDefineClass(c, protectionDomain);\n" + "		return c;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Converts a {@link java.nio.ByteBuffer <tt>ByteBuffer</tt>} into an\n"
				+ "	 * instance of class <tt>Class</tt>, with an optional\n"
				+ "	 * <tt>ProtectionDomain</tt>. If the domain is <tt>null</tt>, then a default\n"
				+ "	 * domain will be assigned to the class as specified in the documentation\n"
				+ "	 * for {@link #defineClass(String, byte[], int, int)}. Before the class can\n"
				+ "	 * be used it must be resolved.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The rules about the first class defined in a package determining the set\n"
				+ "	 * of certificates for the package, and the restrictions on class names are\n"
				+ "	 * identical to those specified in the documentation for\n"
				+ "	 * {@link #defineClass(String, byte[], int, int, ProtectionDomain)}.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * An invocation of this method of the form <i>cl</i><tt>.defineClass(</tt>\n"
				+ "	 * <i>name</i><tt>,</tt> <i>bBuffer</i><tt>,</tt> <i>pd</i><tt>)</tt> yields\n"
				+ "	 * exactly the same result as the statements\n" + "	 *\n" + "	 * <p>\n" + "	 * <tt>\n"
				+ "	 * ...<br>\n" + "	 * byte[] temp = new byte[bBuffer.{@link\n"
				+ "	 * java.nio.ByteBuffer#remaining remaining}()];<br>\n"
				+ "	 *     bBuffer.{@link java.nio.ByteBuffer#get(byte[])\n" + "	 * get}(temp);<br>\n"
				+ "	 *     return {@link #defineClass(String, byte[], int, int, ProtectionDomain)\n"
				+ "	 * cl.defineClass}(name, temp, 0,\n" + "	 * temp.length, pd);<br>\n" + "	 * </tt>\n"
				+ "	 * </p>\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The expected <a href=\"#name\">binary name</a>. of the class, or\n"
				+ "	 *            <tt>null</tt> if not known\n" + "	 *\n" + "	 * @param b\n"
				+ "	 *            The bytes that make up the class data. The bytes from\n"
				+ "	 *            positions <tt>b.position()</tt> through\n"
				+ "	 *            <tt>b.position() + b.limit() -1\n"
				+ "	 *         </tt> should have the format of a valid class file as defined by\n"
				+ "	 *            <cite>The Java&trade; Virtual Machine Specification</cite>.\n" + "	 *\n"
				+ "	 * @param protectionDomain\n"
				+ "	 *            The ProtectionDomain of the class, or <tt>null</tt>.\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object created from the data, and optional\n"
				+ "	 *         <tt>ProtectionDomain</tt>.\n" + "	 *\n" + "	 * @throws ClassFormatError\n"
				+ "	 *             If the data did not contain a valid class.\n" + "	 *\n"
				+ "	 * @throws NoClassDefFoundError\n"
				+ "	 *             If <tt>name</tt> is not equal to the <a href=\"#name\">binary\n"
				+ "	 *             name</a> of the class specified by <tt>b</tt>\n" + "	 *\n"
				+ "	 * @throws SecurityException\n"
				+ "	 *             If an attempt is made to add this class to a package that\n"
				+ "	 *             contains classes that were signed by a different set of\n"
				+ "	 *             certificates than this class, or if <tt>name</tt> begins with\n"
				+ "	 *             \"<tt>java.</tt>\".\n" + "	 *\n"
				+ "	 * @see #defineClass(String, byte[], int, int, ProtectionDomain)\n" + "	 *\n" + "	 * @since 1.5\n"
				+ "	 */\n"
				+ "	protected final Class<?> defineClass(String name, java.nio.ByteBuffer b, ProtectionDomain protectionDomain)\n"
				+ "			throws ClassFormatError {\n" + "		int len = b.remaining();\n" + "\n"
				+ "		// Use byte[] if not a direct ByteBufer:\n" + "		if (!b.isDirect()) {\n"
				+ "			if (b.hasArray()) {\n"
				+ "				return defineClass(name, b.array(), b.position() + b.arrayOffset(), len, protectionDomain);\n"
				+ "			} else {\n" + "				// no array, or read-only array\n"
				+ "				byte[] tb = new byte[len];\n"
				+ "				b.get(tb); // get bytes out of byte buffer.\n"
				+ "				return defineClass(name, tb, 0, len, protectionDomain);\n" + "			}\n"
				+ "		}\n" + "\n" + "		protectionDomain = preDefineClass(name, protectionDomain);\n"
				+ "		String source = defineClassSourceLocation(protectionDomain);\n"
				+ "		Class<?> c = defineClass2(name, b, b.position(), len, protectionDomain, source);\n"
				+ "		postDefineClass(c, protectionDomain);\n" + "		return c;\n" + "	}\n" + "\n"
				+ "	private native Class<?> defineClass0(String name, byte[] b, int off, int len, ProtectionDomain pd);\n"
				+ "\n"
				+ "	private native Class<?> defineClass1(String name, byte[] b, int off, int len, ProtectionDomain pd, String source);\n"
				+ "\n"
				+ "	private native Class<?> defineClass2(String name, java.nio.ByteBuffer b, int off, int len, ProtectionDomain pd,\n"
				+ "			String source);\n" + "\n"
				+ "	// true if the name is null or has the potential to be a valid binary name\n"
				+ "	private boolean checkName(String name) {\n" + "		if ((name == null) || (name.length() == 0))\n"
				+ "			return true;\n"
				+ "		if ((name.indexOf('/') != -1) || (!VM.allowArraySyntax() && (name.charAt(0) == '[')))\n"
				+ "			return false;\n" + "		return true;\n" + "	}\n" + "\n"
				+ "	private void checkCerts(String name, CodeSource cs) {\n"
				+ "		int i = name.lastIndexOf('.');\n"
				+ "		String pname = (i == -1) ? \"\" : name.substring(0, i);\n" + "\n"
				+ "		Certificate[] certs = null;\n" + "		if (cs != null) {\n"
				+ "			certs = cs.getCertificates();\n" + "		}\n" + "		Certificate[] pcerts = null;\n"
				+ "		if (parallelLockMap == null) {\n" + "			synchronized (this) {\n"
				+ "				pcerts = package2certs.get(pname);\n" + "				if (pcerts == null) {\n"
				+ "					package2certs.put(pname, (certs == null ? nocerts : certs));\n" + "				}\n"
				+ "			}\n" + "		} else {\n"
				+ "			pcerts = ((ConcurrentHashMap<String, Certificate[]>) package2certs).putIfAbsent(pname,\n"
				+ "					(certs == null ? nocerts : certs));\n" + "		}\n"
				+ "		if (pcerts != null && !compareCerts(pcerts, certs)) {\n"
				+ "			throw new SecurityException(\"class \\\"\" + name\n"
				+ "					+ \"\\\"'s signer information does not match signer information of other classes in the same package\");\n"
				+ "		}\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * check to make sure the certs for the new class (certs) are the same as\n"
				+ "	 * the certs for the first class inserted in the package (pcerts)\n" + "	 */\n"
				+ "	private boolean compareCerts(Certificate[] pcerts, Certificate[] certs) {\n"
				+ "		// certs can be null, indicating no certs.\n"
				+ "		if ((certs == null) || (certs.length == 0)) {\n" + "			return pcerts.length == 0;\n"
				+ "		}\n" + "\n" + "		// the length must be the same at this point\n"
				+ "		if (certs.length != pcerts.length)\n" + "			return false;\n" + "\n"
				+ "		// go through and make sure all the certs in one array\n"
				+ "		// are in the other and vice-versa.\n" + "		boolean match;\n"
				+ "		for (int i = 0; i < certs.length; i++) {\n" + "			match = false;\n"
				+ "			for (int j = 0; j < pcerts.length; j++) {\n"
				+ "				if (certs[i].equals(pcerts[j])) {\n" + "					match = true;\n"
				+ "					break;\n" + "				}\n" + "			}\n" + "			if (!match)\n"
				+ "				return false;\n" + "		}\n" + "\n" + "		// now do the same for pcerts\n"
				+ "		for (int i = 0; i < pcerts.length; i++) {\n" + "			match = false;\n"
				+ "			for (int j = 0; j < certs.length; j++) {\n"
				+ "				if (pcerts[i].equals(certs[j])) {\n" + "					match = true;\n"
				+ "					break;\n" + "				}\n" + "			}\n" + "			if (!match)\n"
				+ "				return false;\n" + "		}\n" + "\n" + "		return true;\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Links the specified class. This (misleadingly named) method may be used\n"
				+ "	 * by a class loader to link a class. If the class <tt>c</tt> has already\n"
				+ "	 * been linked, then this method simply returns. Otherwise, the class is\n"
				+ "	 * linked as described in the \"Execution\" chapter of <cite>The Java&trade;\n"
				+ "	 * Language Specification</cite>.\n" + "	 *\n" + "	 * @param c\n"
				+ "	 *            The class to link\n" + "	 *\n" + "	 * @throws NullPointerException\n"
				+ "	 *             If <tt>c</tt> is <tt>null</tt>.\n" + "	 *\n"
				+ "	 * @see #defineClass(String, byte[], int, int)\n" + "	 */\n"
				+ "	protected final void resolveClass(Class<?> c) {\n" + "		resolveClass0(c);\n" + "	}\n" + "\n"
				+ "	private native void resolveClass0(Class<?> c);\n" + "\n" + "	/**\n"
				+ "	 * Finds a class with the specified <a href=\"#name\">binary name</a>, loading\n"
				+ "	 * it if necessary.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * This method loads the class through the system class loader (see\n"
				+ "	 * {@link #getSystemClassLoader()}). The <tt>Class</tt> object returned\n"
				+ "	 * might have more than one <tt>ClassLoader</tt> associated with it.\n"
				+ "	 * Subclasses of <tt>ClassLoader</tt> need not usually invoke this method,\n"
				+ "	 * because most class loaders need to override just\n" + "	 * {@link #findClass(String)}.\n"
				+ "	 * </p>\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The <a href=\"#name\">binary name</a> of the class\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object for the specified <tt>name</tt>\n" + "	 *\n"
				+ "	 * @throws ClassNotFoundException\n" + "	 *             If the class could not be found\n"
				+ "	 *\n" + "	 * @see #ClassLoader(ClassLoader)\n" + "	 * @see #getParent()\n" + "	 */\n"
				+ "	protected final Class<?> findSystemClass(String name) throws ClassNotFoundException {\n"
				+ "		ClassLoader system = getSystemClassLoader();\n" + "		if (system == null) {\n"
				+ "			if (!checkName(name))\n" + "				throw new ClassNotFoundException(name);\n"
				+ "			Class<?> cls = findBootstrapClass(name);\n" + "			if (cls == null) {\n"
				+ "				throw new ClassNotFoundException(name);\n" + "			}\n"
				+ "			return cls;\n" + "		}\n" + "		return system.loadClass(name);\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Returns a class loaded by the bootstrap class loader; or return null if\n"
				+ "	 * not found.\n" + "	 */\n" + "	private Class<?> findBootstrapClassOrNull(String name) {\n"
				+ "		if (!checkName(name))\n" + "			return null;\n" + "\n"
				+ "		return findBootstrapClass(name);\n" + "	}\n" + "\n" + "	// return null if not found\n"
				+ "	private native Class<?> findBootstrapClass(String name);\n" + "\n" + "	/**\n"
				+ "	 * Returns the class with the given <a href=\"#name\">binary name</a> if this\n"
				+ "	 * loader has been recorded by the Java virtual machine as an initiating\n"
				+ "	 * loader of a class with that <a href=\"#name\">binary name</a>. Otherwise\n"
				+ "	 * <tt>null</tt> is returned.\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The <a href=\"#name\">binary name</a> of the class\n" + "	 *\n"
				+ "	 * @return The <tt>Class</tt> object, or <tt>null</tt> if the class has not\n"
				+ "	 *         been loaded\n" + "	 *\n" + "	 * @since 1.1\n" + "	 */\n"
				+ "	protected final Class<?> findLoadedClass(String name) {\n" + "		if (!checkName(name))\n"
				+ "			return null;\n" + "		return findLoadedClass0(name);\n" + "	}\n" + "\n"
				+ "	private native final Class<?> findLoadedClass0(String name);\n" + "\n" + "	/**\n"
				+ "	 * Sets the signers of a class. This should be invoked after defining a\n" + "	 * class.\n"
				+ "	 *\n" + "	 * @param c\n" + "	 *            The <tt>Class</tt> object\n" + "	 *\n"
				+ "	 * @param signers\n" + "	 *            The signers for the class\n" + "	 *\n"
				+ "	 * @since 1.1\n" + "	 */\n"
				+ "	protected final void setSigners(Class<?> c, Object[] signers) {\n"
				+ "		c.setSigners(signers);\n" + "	}\n" + "\n" + "	// -- Resource --\n" + "\n" + "	/**\n"
				+ "	 * Finds the resource with the given name. A resource is some data (images,\n"
				+ "	 * audio, text, etc) that can be accessed by class code in a way that is\n"
				+ "	 * independent of the location of the code.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The name of a resource is a '<tt>/</tt>'-separated path name that\n"
				+ "	 * identifies the resource.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * This method will first search the parent class loader for the resource;\n"
				+ "	 * if the parent is <tt>null</tt> the path of the class loader built-in to\n"
				+ "	 * the virtual machine is searched. That failing, this method will invoke\n"
				+ "	 * {@link #findResource(String)} to find the resource.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @apiNote When overriding this method it is recommended that an\n"
				+ "	 *          implementation ensures that any delegation is consistent with\n"
				+ "	 *          the {@link #getResources(java.lang.String) getResources(String)}\n"
				+ "	 *          method.\n" + "	 *\n" + "	 * @param name\n" + "	 *            The resource name\n"
				+ "	 *\n" + "	 * @return A <tt>URL</tt> object for reading the resource, or <tt>null</tt>\n"
				+ "	 *         if the resource could not be found or the invoker doesn't have\n"
				+ "	 *         adequate privileges to get the resource.\n" + "	 *\n" + "	 * @since 1.1\n"
				+ "	 */\n" + "	public URL getResource(String name) {\n" + "		URL url;\n"
				+ "		if (parent != null) {\n" + "			url = parent.getResource(name);\n" + "		} else {\n"
				+ "			url = getBootstrapResource(name);\n" + "		}\n" + "		if (url == null) {\n"
				+ "			url = findResource(name);\n" + "		}\n" + "		return url;\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Finds all the resources with the given name. A resource is some data\n"
				+ "	 * (images, audio, text, etc) that can be accessed by class code in a way\n"
				+ "	 * that is independent of the location of the code.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The name of a resource is a <tt>/</tt>-separated path name that\n"
				+ "	 * identifies the resource.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The search order is described in the documentation for\n"
				+ "	 * {@link #getResource(String)}.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @apiNote When overriding this method it is recommended that an\n"
				+ "	 *          implementation ensures that any delegation is consistent with\n"
				+ "	 *          the {@link #getResource(java.lang.String) getResource(String)}\n"
				+ "	 *          method. This should ensure that the first element returned by\n"
				+ "	 *          the Enumeration's {@code nextElement} method is the same\n"
				+ "	 *          resource that the {@code getResource(String)} method would\n"
				+ "	 *          return.\n" + "	 *\n" + "	 * @param name\n" + "	 *            The resource name\n"
				+ "	 *\n" + "	 * @return An enumeration of {@link java.net.URL <tt>URL</tt>} objects for\n"
				+ "	 *         the resource. If no resources could be found, the enumeration\n"
				+ "	 *         will be empty. Resources that the class loader doesn't have\n"
				+ "	 *         access to will not be in the enumeration.\n" + "	 *\n" + "	 * @throws IOException\n"
				+ "	 *             If I/O errors occur\n" + "	 *\n" + "	 * @see #findResources(String)\n"
				+ "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	public Enumeration<URL> getResources(String name) throws IOException {\n"
				+ "		@SuppressWarnings(\"unchecked\")\n"
				+ "		Enumeration<URL>[] tmp = (Enumeration<URL>[]) new Enumeration<?>[2];\n"
				+ "		if (parent != null) {\n" + "			tmp[0] = parent.getResources(name);\n"
				+ "		} else {\n" + "			tmp[0] = getBootstrapResources(name);\n" + "		}\n"
				+ "		tmp[1] = findResources(name);\n" + "\n" + "		return new CompoundEnumeration<>(tmp);\n"
				+ "	}\n" + "\n" + "	/**\n"
				+ "	 * Finds the resource with the given name. Class loader implementations\n"
				+ "	 * should override this method to specify where to find resources.\n" + "	 *\n"
				+ "	 * @param name\n" + "	 *            The resource name\n" + "	 *\n"
				+ "	 * @return A <tt>URL</tt> object for reading the resource, or <tt>null</tt>\n"
				+ "	 *         if the resource could not be found\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected URL findResource(String name) {\n" + "		return null;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns an enumeration of {@link java.net.URL <tt>URL</tt>} objects\n"
				+ "	 * representing all the resources with the given name. Class loader\n"
				+ "	 * implementations should override this method to specify where to load\n"
				+ "	 * resources from.\n" + "	 *\n" + "	 * @param name\n" + "	 *            The resource name\n"
				+ "	 *\n" + "	 * @return An enumeration of {@link java.net.URL <tt>URL</tt>} objects for\n"
				+ "	 *         the resources\n" + "	 *\n" + "	 * @throws IOException\n"
				+ "	 *             If I/O errors occur\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected Enumeration<URL> findResources(String name) throws IOException {\n"
				+ "		return java.util.Collections.emptyEnumeration();\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Registers the caller as parallel capable. The registration succeeds if\n"
				+ "	 * and only if all of the following conditions are met:\n" + "	 * <ol>\n"
				+ "	 * <li>no instance of the caller has been created</li>\n"
				+ "	 * <li>all of the super classes (except class Object) of the caller are\n"
				+ "	 * registered as parallel capable</li>\n" + "	 * </ol>\n" + "	 * <p>\n"
				+ "	 * Note that once a class loader is registered as parallel capable, there is\n"
				+ "	 * no way to change it back.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @return true if the caller is successfully registered as parallel capable\n"
				+ "	 *         and false if otherwise.\n" + "	 *\n" + "	 * @since 1.7\n" + "	 */\n"
				+ "	@CallerSensitive\n" + "	protected static boolean registerAsParallelCapable() {\n"
				+ "		Class<? extends ClassLoader> callerClass = Reflection.getCallerClass().asSubclass(ClassLoader.class);\n"
				+ "		return ParallelLoaders.register(callerClass);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Find a resource of the specified name from the search path used to load\n"
				+ "	 * classes. This method locates the resource through the system class loader\n"
				+ "	 * (see {@link #getSystemClassLoader()}).\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The resource name\n" + "	 *\n"
				+ "	 * @return A {@link java.net.URL <tt>URL</tt>} object for reading the\n"
				+ "	 *         resource, or <tt>null</tt> if the resource could not be found\n" + "	 *\n"
				+ "	 * @since 1.1\n" + "	 */\n" + "	public static URL getSystemResource(String name) {\n"
				+ "		ClassLoader system = getSystemClassLoader();\n" + "		if (system == null) {\n"
				+ "			return getBootstrapResource(name);\n" + "		}\n"
				+ "		return system.getResource(name);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Finds all resources of the specified name from the search path used to\n"
				+ "	 * load classes. The resources thus found are returned as an\n"
				+ "	 * {@link java.util.Enumeration <tt>Enumeration</tt>} of {@link java.net.URL\n"
				+ "	 * <tt>URL</tt>} objects.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The search order is described in the documentation for\n"
				+ "	 * {@link #getSystemResource(String)}.\n" + "	 * </p>\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The resource name\n" + "	 *\n"
				+ "	 * @return An enumeration of resource {@link java.net.URL <tt>URL</tt>}\n"
				+ "	 *         objects\n" + "	 *\n" + "	 * @throws IOException\n"
				+ "	 *             If I/O errors occur\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	public static Enumeration<URL> getSystemResources(String name) throws IOException {\n"
				+ "		ClassLoader system = getSystemClassLoader();\n" + "		if (system == null) {\n"
				+ "			return getBootstrapResources(name);\n" + "		}\n"
				+ "		return system.getResources(name);\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Find resources from the VM's built-in classloader.\n" + "	 */\n"
				+ "	private static URL getBootstrapResource(String name) {\n"
				+ "		URLClassPath ucp = getBootstrapClassPath();\n" + "		Resource res = ucp.getResource(name);\n"
				+ "		return res != null ? res.getURL() : null;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Find resources from the VM's built-in classloader.\n" + "	 */\n"
				+ "	private static Enumeration<URL> getBootstrapResources(String name) throws IOException {\n"
				+ "		final Enumeration<Resource> e = getBootstrapClassPath().getResources(name);\n"
				+ "		return new Enumeration<URL>() {\n" + "			public URL nextElement() {\n"
				+ "				return e.nextElement().getURL();\n" + "			}\n" + "\n"
				+ "			public boolean hasMoreElements() {\n" + "				return e.hasMoreElements();\n"
				+ "			}\n" + "		};\n" + "	}\n" + "\n"
				+ "	// Returns the URLClassPath that is used for finding system resources.\n"
				+ "	static URLClassPath getBootstrapClassPath() {\n"
				+ "		return sun.misc.Launcher.getBootstrapClassPath();\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns an input stream for reading the specified resource.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The search order is described in the documentation for\n"
				+ "	 * {@link #getResource(String)}.\n" + "	 * </p>\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The resource name\n" + "	 *\n"
				+ "	 * @return An input stream for reading the resource, or <tt>null</tt> if the\n"
				+ "	 *         resource could not be found\n" + "	 *\n" + "	 * @since 1.1\n" + "	 */\n"
				+ "	public InputStream getResourceAsStream(String name) {\n" + "		URL url = getResource(name);\n"
				+ "		try {\n" + "			return url != null ? url.openStream() : null;\n"
				+ "		} catch (IOException e) {\n" + "			return null;\n" + "		}\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Open for reading, a resource of the specified name from the search path\n"
				+ "	 * used to load classes. This method locates the resource through the system\n"
				+ "	 * class loader (see {@link #getSystemClassLoader()}).\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The resource name\n" + "	 *\n"
				+ "	 * @return An input stream for reading the resource, or <tt>null</tt> if the\n"
				+ "	 *         resource could not be found\n" + "	 *\n" + "	 * @since 1.1\n" + "	 */\n"
				+ "	public static InputStream getSystemResourceAsStream(String name) {\n"
				+ "		URL url = getSystemResource(name);\n" + "		try {\n"
				+ "			return url != null ? url.openStream() : null;\n" + "		} catch (IOException e) {\n"
				+ "			return null;\n" + "		}\n" + "	}\n" + "\n" + "	// -- Hierarchy --\n" + "\n"
				+ "	/**\n" + "	 * Returns the parent class loader for delegation. Some implementations may\n"
				+ "	 * use <tt>null</tt> to represent the bootstrap class loader. This method\n"
				+ "	 * will return <tt>null</tt> in such implementations if this class loader's\n"
				+ "	 * parent is the bootstrap class loader.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * If a security manager is present, and the invoker's class loader is not\n"
				+ "	 * <tt>null</tt> and is not an ancestor of this class loader, then this\n"
				+ "	 * method invokes the security manager's\n"
				+ "	 * {@link SecurityManager#checkPermission(java.security.Permission)\n"
				+ "	 * <tt>checkPermission</tt>} method with a\n"
				+ "	 * {@link RuntimePermission#RuntimePermission(String)\n"
				+ "	 * <tt>RuntimePermission(\"getClassLoader\")</tt>} permission to verify access\n"
				+ "	 * to the parent class loader is permitted. If not, a\n"
				+ "	 * <tt>SecurityException</tt> will be thrown.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @return The parent <tt>ClassLoader</tt>\n" + "	 *\n" + "	 * @throws SecurityException\n"
				+ "	 *             If a security manager exists and its <tt>checkPermission</tt>\n"
				+ "	 *             method doesn't allow access to this class loader's parent\n"
				+ "	 *             class loader.\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	@CallerSensitive\n" + "	public final ClassLoader getParent() {\n" + "		if (parent == null)\n"
				+ "			return null;\n" + "		SecurityManager sm = System.getSecurityManager();\n"
				+ "		if (sm != null) {\n" + "			// Check access to the parent class loader\n"
				+ "			// If the caller's class loader is same as this class loader,\n"
				+ "			// permission check is performed.\n"
				+ "			checkClassLoaderPermission(parent, Reflection.getCallerClass());\n" + "		}\n"
				+ "		return parent;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns the system class loader for delegation. This is the default\n"
				+ "	 * delegation parent for new <tt>ClassLoader</tt> instances, and is\n"
				+ "	 * typically the class loader used to start the application.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * This method is first invoked early in the runtime's startup sequence, at\n"
				+ "	 * which point it creates the system class loader and sets it as the context\n"
				+ "	 * class loader of the invoking <tt>Thread</tt>.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * The default system class loader is an implementation-dependent instance\n"
				+ "	 * of this class.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * If the system property \"<tt>java.system.class.loader</tt>\" is defined\n"
				+ "	 * when this method is first invoked then the value of that property is\n"
				+ "	 * taken to be the name of a class that will be returned as the system class\n"
				+ "	 * loader. The class is loaded using the default system class loader and\n"
				+ "	 * must define a public constructor that takes a single parameter of type\n"
				+ "	 * <tt>ClassLoader</tt> which is used as the delegation parent. An instance\n"
				+ "	 * is then created using this constructor with the default system class\n"
				+ "	 * loader as the parameter. The resulting class loader is defined to be the\n"
				+ "	 * system class loader.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * If a security manager is present, and the invoker's class loader is not\n"
				+ "	 * <tt>null</tt> and the invoker's class loader is not the same as or an\n"
				+ "	 * ancestor of the system class loader, then this method invokes the\n" + "	 * security manager's\n"
				+ "	 * {@link SecurityManager#checkPermission(java.security.Permission)\n"
				+ "	 * <tt>checkPermission</tt>} method with a\n"
				+ "	 * {@link RuntimePermission#RuntimePermission(String)\n"
				+ "	 * <tt>RuntimePermission(\"getClassLoader\")</tt>} permission to verify access\n"
				+ "	 * to the system class loader. If not, a <tt>SecurityException</tt> will be\n" + "	 * thrown.\n"
				+ "	 * </p>\n" + "	 *\n"
				+ "	 * @return The system <tt>ClassLoader</tt> for delegation, or <tt>null</tt>\n"
				+ "	 *         if none\n" + "	 *\n" + "	 * @throws SecurityException\n"
				+ "	 *             If a security manager exists and its <tt>checkPermission</tt>\n"
				+ "	 *             method doesn't allow access to the system class loader.\n" + "	 *\n"
				+ "	 * @throws IllegalStateException\n"
				+ "	 *             If invoked recursively during the construction of the class\n"
				+ "	 *             loader specified by the \"<tt>java.system.class.loader</tt>\"\n"
				+ "	 *             property.\n" + "	 *\n" + "	 * @throws Error\n"
				+ "	 *             If the system property \"<tt>java.system.class.loader</tt>\" is\n"
				+ "	 *             defined but the named class could not be loaded, the provider\n"
				+ "	 *             class does not define the required constructor, or an\n"
				+ "	 *             exception is thrown by that constructor when it is invoked.\n"
				+ "	 *             The underlying cause of the error can be retrieved via the\n"
				+ "	 *             {@link Throwable#getCause()} method.\n" + "	 *\n" + "	 * @revised 1.4\n"
				+ "	 */\n" + "	@CallerSensitive\n" + "	public static ClassLoader getSystemClassLoader() {\n"
				+ "		initSystemClassLoader();\n" + "		if (scl == null) {\n" + "			return null;\n"
				+ "		}\n" + "		SecurityManager sm = System.getSecurityManager();\n"
				+ "		if (sm != null) {\n"
				+ "			checkClassLoaderPermission(scl, Reflection.getCallerClass());\n" + "		}\n"
				+ "		return scl;\n" + "	}\n" + "\n"
				+ "	private static synchronized void initSystemClassLoader() {\n" + "		if (!sclSet) {\n"
				+ "			if (scl != null)\n"
				+ "				throw new IllegalStateException(\"recursive invocation\");\n"
				+ "			sun.misc.Launcher l = sun.misc.Launcher.getLauncher();\n" + "			if (l != null) {\n"
				+ "				Throwable oops = null;\n" + "				scl = l.getClassLoader();\n"
				+ "				try {\n"
				+ "					scl = AccessController.doPrivileged(new SystemClassLoaderAction(scl));\n"
				+ "				} catch (PrivilegedActionException pae) {\n"
				+ "					oops = pae.getCause();\n"
				+ "					if (oops instanceof InvocationTargetException) {\n"
				+ "						oops = oops.getCause();\n" + "					}\n" + "				}\n"
				+ "				if (oops != null) {\n" + "					if (oops instanceof Error) {\n"
				+ "						throw (Error) oops;\n" + "					} else {\n"
				+ "						// wrap the exception\n" + "						throw new Error(oops);\n"
				+ "					}\n" + "				}\n" + "			}\n" + "			sclSet = true;\n"
				+ "		}\n" + "	}\n" + "\n"
				+ "	// Returns true if the specified class loader can be found in this class\n"
				+ "	// loader's delegation chain.\n" + "	boolean isAncestor(ClassLoader cl) {\n"
				+ "		ClassLoader acl = this;\n" + "		do {\n" + "			acl = acl.parent;\n"
				+ "			if (cl == acl) {\n" + "				return true;\n" + "			}\n"
				+ "		} while (acl != null);\n" + "		return false;\n" + "	}\n" + "\n"
				+ "	// Tests if class loader access requires \"getClassLoader\" permission\n"
				+ "	// check. A class loader 'from' can access class loader 'to' if\n"
				+ "	// class loader 'from' is same as class loader 'to' or an ancestor\n"
				+ "	// of 'to'. The class loader in a system domain can access\n" + "	// any class loader.\n"
				+ "	private static boolean needsClassLoaderPermissionCheck(ClassLoader from, ClassLoader to) {\n"
				+ "		if (from == to)\n" + "			return false;\n" + "\n" + "		if (from == null)\n"
				+ "			return false;\n" + "\n" + "		return !to.isAncestor(from);\n" + "	}\n" + "\n"
				+ "	// Returns the class's class loader, or null if none.\n"
				+ "	static ClassLoader getClassLoader(Class<?> caller) {\n"
				+ "		// This can be null if the VM is requesting it\n" + "		if (caller == null) {\n"
				+ "			return null;\n" + "		}\n"
				+ "		// Circumvent security check since this is package-private\n"
				+ "		return caller.getClassLoader0();\n" + "	}\n" + "\n" + "	/*\n"
				+ "	 * Checks RuntimePermission(\"getClassLoader\") permission if caller's class\n"
				+ "	 * loader is not null and caller's class loader is not the same as or an\n"
				+ "	 * ancestor of the given cl argument.\n" + "	 */\n"
				+ "	static void checkClassLoaderPermission(ClassLoader cl, Class<?> caller) {\n"
				+ "		SecurityManager sm = System.getSecurityManager();\n" + "		if (sm != null) {\n"
				+ "			// caller can be null if the VM is requesting it\n"
				+ "			ClassLoader ccl = getClassLoader(caller);\n"
				+ "			if (needsClassLoaderPermissionCheck(ccl, cl)) {\n"
				+ "				sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n" + "			}\n"
				+ "		}\n" + "	}\n" + "\n" + "	// The class loader for the system\n"
				+ "	// @GuardedBy(\"ClassLoader.class\")\n" + "	private static ClassLoader scl;\n" + "\n"
				+ "	// Set to true once the system class loader has been set\n"
				+ "	// @GuardedBy(\"ClassLoader.class\")\n" + "	private static boolean sclSet;\n" + "\n"
				+ "	// -- Package --\n" + "\n" + "	/**\n"
				+ "	 * Defines a package by name in this <tt>ClassLoader</tt>. This allows class\n"
				+ "	 * loaders to define the packages for their classes. Packages must be\n"
				+ "	 * created before the class is defined, and package names must be unique\n"
				+ "	 * within a class loader and cannot be redefined or changed once created.\n" + "	 *\n"
				+ "	 * @param name\n" + "	 *            The package name\n" + "	 *\n" + "	 * @param specTitle\n"
				+ "	 *            The specification title\n" + "	 *\n" + "	 * @param specVersion\n"
				+ "	 *            The specification version\n" + "	 *\n" + "	 * @param specVendor\n"
				+ "	 *            The specification vendor\n" + "	 *\n" + "	 * @param implTitle\n"
				+ "	 *            The implementation title\n" + "	 *\n" + "	 * @param implVersion\n"
				+ "	 *            The implementation version\n" + "	 *\n" + "	 * @param implVendor\n"
				+ "	 *            The implementation vendor\n" + "	 *\n" + "	 * @param sealBase\n"
				+ "	 *            If not <tt>null</tt>, then this package is sealed with respect\n"
				+ "	 *            to the given code source {@link java.net.URL <tt>URL</tt>}\n"
				+ "	 *            object. Otherwise, the package is not sealed.\n" + "	 *\n"
				+ "	 * @return The newly defined <tt>Package</tt> object\n" + "	 *\n"
				+ "	 * @throws IllegalArgumentException\n"
				+ "	 *             If package name duplicates an existing package either in this\n"
				+ "	 *             class loader or one of its ancestors\n" + "	 *\n" + "	 * @since 1.2\n"
				+ "	 */\n"
				+ "	protected Package definePackage(String name, String specTitle, String specVersion, String specVendor,\n"
				+ "			String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException {\n"
				+ "		synchronized (packages) {\n" + "			Package pkg = getPackage(name);\n"
				+ "			if (pkg != null) {\n" + "				throw new IllegalArgumentException(name);\n"
				+ "			}\n"
				+ "			pkg = new Package(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase,\n"
				+ "					this);\n" + "			packages.put(name, pkg);\n" + "			return pkg;\n"
				+ "		}\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns a <tt>Package</tt> that has been defined by this class loader or\n"
				+ "	 * any of its ancestors.\n" + "	 *\n" + "	 * @param name\n"
				+ "	 *            The package name\n" + "	 *\n"
				+ "	 * @return The <tt>Package</tt> corresponding to the given name, or\n"
				+ "	 *         <tt>null</tt> if not found\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected Package getPackage(String name) {\n" + "		Package pkg;\n"
				+ "		synchronized (packages) {\n" + "			pkg = packages.get(name);\n" + "		}\n"
				+ "		if (pkg == null) {\n" + "			if (parent != null) {\n"
				+ "				pkg = parent.getPackage(name);\n" + "			} else {\n"
				+ "				pkg = Package.getSystemPackage(name);\n" + "			}\n"
				+ "			if (pkg != null) {\n" + "				synchronized (packages) {\n"
				+ "					Package pkg2 = packages.get(name);\n" + "					if (pkg2 == null) {\n"
				+ "						packages.put(name, pkg);\n" + "					} else {\n"
				+ "						pkg = pkg2;\n" + "					}\n" + "				}\n"
				+ "			}\n" + "		}\n" + "		return pkg;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns all of the <tt>Packages</tt> defined by this class loader and its\n" + "	 * ancestors.\n"
				+ "	 *\n" + "	 * @return The array of <tt>Package</tt> objects defined by this\n"
				+ "	 *         <tt>ClassLoader</tt>\n" + "	 *\n" + "	 * @since 1.2\n" + "	 */\n"
				+ "	protected Package[] getPackages() {\n" + "		Map<String, Package> map;\n"
				+ "		synchronized (packages) {\n" + "			map = new HashMap<>(packages);\n" + "		}\n"
				+ "		Package[] pkgs;\n" + "		if (parent != null) {\n"
				+ "			pkgs = parent.getPackages();\n" + "		} else {\n"
				+ "			pkgs = Package.getSystemPackages();\n" + "		}\n" + "		if (pkgs != null) {\n"
				+ "			for (int i = 0; i < pkgs.length; i++) {\n"
				+ "				String pkgName = pkgs[i].getName();\n"
				+ "				if (map.get(pkgName) == null) {\n" + "					map.put(pkgName, pkgs[i]);\n"
				+ "				}\n" + "			}\n" + "		}\n"
				+ "		return map.values().toArray(new Package[map.size()]);\n" + "	}\n" + "\n"
				+ "	// -- Native library access --\n" + "\n" + "	/**\n"
				+ "	 * Returns the absolute path name of a native library. The VM invokes this\n"
				+ "	 * method to locate the native libraries that belong to classes loaded with\n"
				+ "	 * this class loader. If this method returns <tt>null</tt>, the VM searches\n"
				+ "	 * the library along the path specified as the \"<tt>java.library.path</tt>\"\n"
				+ "	 * property.\n" + "	 *\n" + "	 * @param libname\n" + "	 *            The library name\n"
				+ "	 *\n" + "	 * @return The absolute path of the native library\n" + "	 *\n"
				+ "	 * @see System#loadLibrary(String)\n" + "	 * @see System#mapLibraryName(String)\n" + "	 *\n"
				+ "	 * @since 1.2\n" + "	 */\n" + "	protected String findLibrary(String libname) {\n"
				+ "		return null;\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * The inner class NativeLibrary denotes a loaded native library instance.\n"
				+ "	 * Every classloader contains a vector of loaded native libraries in the\n"
				+ "	 * private field <tt>nativeLibraries</tt>. The native libraries loaded into\n"
				+ "	 * the system are entered into the <tt>systemNativeLibraries</tt> vector.\n" + "	 *\n"
				+ "	 * <p>\n" + "	 * Every native library requires a particular version of JNI. This is\n"
				+ "	 * denoted by the private <tt>jniVersion</tt> field. This field is set by\n"
				+ "	 * the VM when it loads the library, and used by the VM to pass the correct\n"
				+ "	 * version of JNI to the native methods.\n" + "	 * </p>\n" + "	 *\n" + "	 * @see ClassLoader\n"
				+ "	 * @since 1.2\n" + "	 */\n" + "	static class NativeLibrary {\n"
				+ "		// opaque handle to native library, used in native code.\n" + "		long handle;\n"
				+ "		// the version of JNI environment the native library requires.\n"
				+ "		private int jniVersion;\n"
				+ "		// the class from which the library is loaded, also indicates\n"
				+ "		// the loader this native library belongs.\n" + "		private final Class<?> fromClass;\n"
				+ "		// the canonicalized name of the native library.\n" + "		// or static library name\n"
				+ "		String name;\n" + "		// Indicates if the native library is linked into the VM\n"
				+ "		boolean isBuiltin;\n" + "		// Indicates if the native library is loaded\n"
				+ "		boolean loaded;\n" + "\n" + "		native void load(String name, boolean isBuiltin);\n" + "\n"
				+ "		native long find(String name);\n" + "\n"
				+ "		native void unload(String name, boolean isBuiltin);\n" + "\n"
				+ "		public NativeLibrary(Class<?> fromClass, String name, boolean isBuiltin) {\n"
				+ "			this.name = name;\n" + "			this.fromClass = fromClass;\n"
				+ "			this.isBuiltin = isBuiltin;\n" + "		}\n" + "\n" + "		protected void finalize() {\n"
				+ "			synchronized (loadedLibraryNames) {\n"
				+ "				if (fromClass.getClassLoader() != null && loaded) {\n"
				+ "					/* remove the native library name */\n"
				+ "					int size = loadedLibraryNames.size();\n"
				+ "					for (int i = 0; i < size; i++) {\n"
				+ "						if (name.equals(loadedLibraryNames.elementAt(i))) {\n"
				+ "							loadedLibraryNames.removeElementAt(i);\n"
				+ "							break;\n" + "						}\n" + "					}\n"
				+ "					/* unload the library. */\n"
				+ "					ClassLoader.nativeLibraryContext.push(this);\n" + "					try {\n"
				+ "						unload(name, isBuiltin);\n" + "					} finally {\n"
				+ "						ClassLoader.nativeLibraryContext.pop();\n" + "					}\n"
				+ "				}\n" + "			}\n" + "		}\n" + "\n"
				+ "		// Invoked in the VM to determine the context class in\n" + "		// JNI_Load/JNI_Unload\n"
				+ "		static Class<?> getFromClass() {\n"
				+ "			return ClassLoader.nativeLibraryContext.peek().fromClass;\n" + "		}\n" + "	}\n"
				+ "\n" + "	// All native library names we've loaded.\n"
				+ "	private static Vector<String> loadedLibraryNames = new Vector<>();\n" + "\n"
				+ "	// Native libraries belonging to system classes.\n"
				+ "	private static Vector<NativeLibrary> systemNativeLibraries = new Vector<>();\n" + "\n"
				+ "	// Native libraries associated with the class loader.\n"
				+ "	private Vector<NativeLibrary> nativeLibraries = new Vector<>();\n" + "\n"
				+ "	// native libraries being loaded/unloaded.\n"
				+ "	private static Stack<NativeLibrary> nativeLibraryContext = new Stack<>();\n" + "\n"
				+ "	// The paths searched for libraries\n" + "	private static String usr_paths[];\n"
				+ "	private static String sys_paths[];\n" + "\n"
				+ "	private static String[] initializePath(String propname) {\n"
				+ "		String ldpath = System.getProperty(propname, \"\");\n"
				+ "		String ps = File.pathSeparator;\n" + "		int ldlen = ldpath.length();\n"
				+ "		int i, j, n;\n" + "		// Count the separators in the path\n"
				+ "		i = ldpath.indexOf(ps);\n" + "		n = 0;\n" + "		while (i >= 0) {\n" + "			n++;\n"
				+ "			i = ldpath.indexOf(ps, i + 1);\n" + "		}\n" + "\n"
				+ "		// allocate the array of paths - n :'s = n + 1 path elements\n"
				+ "		String[] paths = new String[n + 1];\n" + "\n"
				+ "		// Fill the array with paths from the ldpath\n" + "		n = i = 0;\n"
				+ "		j = ldpath.indexOf(ps);\n" + "		while (j >= 0) {\n" + "			if (j - i > 0) {\n"
				+ "				paths[n++] = ldpath.substring(i, j);\n" + "			} else if (j - i == 0) {\n"
				+ "				paths[n++] = \".\";\n" + "			}\n" + "			i = j + 1;\n"
				+ "			j = ldpath.indexOf(ps, i);\n" + "		}\n"
				+ "		paths[n] = ldpath.substring(i, ldlen);\n" + "		return paths;\n" + "	}\n" + "\n"
				+ "	// Invoked in the java.lang.Runtime class to implement load and loadLibrary.\n"
				+ "	static void loadLibrary(Class<?> fromClass, String name, boolean isAbsolute) {\n"
				+ "		ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n"
				+ "		if (sys_paths == null) {\n" + "			usr_paths = initializePath(\"java.library.path\");\n"
				+ "			sys_paths = initializePath(\"sun.boot.library.path\");\n" + "		}\n"
				+ "		if (isAbsolute) {\n" + "			if (loadLibrary0(fromClass, new File(name))) {\n"
				+ "				return;\n" + "			}\n"
				+ "			throw new UnsatisfiedLinkError(\"Can't load library: \" + name);\n" + "		}\n"
				+ "		if (loader != null) {\n" + "			String libfilename = loader.findLibrary(name);\n"
				+ "			if (libfilename != null) {\n" + "				File libfile = new File(libfilename);\n"
				+ "				if (!libfile.isAbsolute()) {\n" + "					throw new UnsatisfiedLinkError(\n"
				+ "							\"ClassLoader.findLibrary failed to return an absolute path: \" + libfilename);\n"
				+ "				}\n" + "				if (loadLibrary0(fromClass, libfile)) {\n"
				+ "					return;\n" + "				}\n"
				+ "				throw new UnsatisfiedLinkError(\"Can't load \" + libfilename);\n" + "			}\n"
				+ "		}\n" + "		for (int i = 0; i < sys_paths.length; i++) {\n"
				+ "			File libfile = new File(sys_paths[i], System.mapLibraryName(name));\n"
				+ "			if (loadLibrary0(fromClass, libfile)) {\n" + "				return;\n" + "			}\n"
				+ "			libfile = ClassLoaderHelper.mapAlternativeName(libfile);\n"
				+ "			if (libfile != null && loadLibrary0(fromClass, libfile)) {\n" + "				return;\n"
				+ "			}\n" + "		}\n" + "		if (loader != null) {\n"
				+ "			for (int i = 0; i < usr_paths.length; i++) {\n"
				+ "				File libfile = new File(usr_paths[i], System.mapLibraryName(name));\n"
				+ "				if (loadLibrary0(fromClass, libfile)) {\n" + "					return;\n"
				+ "				}\n" + "				libfile = ClassLoaderHelper.mapAlternativeName(libfile);\n"
				+ "				if (libfile != null && loadLibrary0(fromClass, libfile)) {\n"
				+ "					return;\n" + "				}\n" + "			}\n" + "		}\n"
				+ "		// Oops, it failed\n"
				+ "		throw new UnsatisfiedLinkError(\"no \" + name + \" in java.library.path\");\n" + "	}\n" + "\n"
				+ "	private static native String findBuiltinLib(String name);\n" + "\n"
				+ "	private static boolean loadLibrary0(Class<?> fromClass, final File file) {\n"
				+ "		// Check to see if we're attempting to access a static library\n"
				+ "		String name = findBuiltinLib(file.getName());\n"
				+ "		boolean isBuiltin = (name != null);\n" + "		if (!isBuiltin) {\n"
				+ "			boolean exists = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n"
				+ "				public Object run() {\n"
				+ "					return file.exists() ? Boolean.TRUE : null;\n" + "				}\n"
				+ "			}) != null;\n" + "			if (!exists) {\n" + "				return false;\n"
				+ "			}\n" + "			try {\n" + "				name = file.getCanonicalPath();\n"
				+ "			} catch (IOException e) {\n" + "				return false;\n" + "			}\n"
				+ "		}\n" + "		ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\n"
				+ "		Vector<NativeLibrary> libs = loader != null ? loader.nativeLibraries : systemNativeLibraries;\n"
				+ "		synchronized (libs) {\n" + "			int size = libs.size();\n"
				+ "			for (int i = 0; i < size; i++) {\n"
				+ "				NativeLibrary lib = libs.elementAt(i);\n"
				+ "				if (name.equals(lib.name)) {\n" + "					return true;\n" + "				}\n"
				+ "			}\n" + "\n" + "			synchronized (loadedLibraryNames) {\n"
				+ "				if (loadedLibraryNames.contains(name)) {\n"
				+ "					throw new UnsatisfiedLinkError(\"Native Library \" + name + \" already loaded in another classloader\");\n"
				+ "				}\n" + "				/*\n"
				+ "				 * If the library is being loaded (must be by the same thread,\n"
				+ "				 * because Runtime.load and Runtime.loadLibrary are\n"
				+ "				 * synchronous). The reason is can occur is that the JNI_OnLoad\n"
				+ "				 * function can cause another loadLibrary invocation.\n" + "				 *\n"
				+ "				 * Thus we can use a static stack to hold the list of libraries\n"
				+ "				 * we are loading.\n" + "				 *\n"
				+ "				 * If there is a pending load operation for the library, we\n"
				+ "				 * immediately return success; otherwise, we raise\n"
				+ "				 * UnsatisfiedLinkError.\n" + "				 */\n"
				+ "				int n = nativeLibraryContext.size();\n" + "				for (int i = 0; i < n; i++) {\n"
				+ "					NativeLibrary lib = nativeLibraryContext.elementAt(i);\n"
				+ "					if (name.equals(lib.name)) {\n"
				+ "						if (loader == lib.fromClass.getClassLoader()) {\n"
				+ "							return true;\n" + "						} else {\n"
				+ "							throw new UnsatisfiedLinkError(\n"
				+ "									\"Native Library \" + name + \" is being loaded in another classloader\");\n"
				+ "						}\n" + "					}\n" + "				}\n"
				+ "				NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);\n"
				+ "				nativeLibraryContext.push(lib);\n" + "				try {\n"
				+ "					lib.load(name, isBuiltin);\n" + "				} finally {\n"
				+ "					nativeLibraryContext.pop();\n" + "				}\n"
				+ "				if (lib.loaded) {\n" + "					loadedLibraryNames.addElement(name);\n"
				+ "					libs.addElement(lib);\n" + "					return true;\n" + "				}\n"
				+ "				return false;\n" + "			}\n" + "		}\n" + "	}\n" + "\n"
				+ "	// Invoked in the VM class linking code.\n"
				+ "	static long findNative(ClassLoader loader, String name) {\n"
				+ "		Vector<NativeLibrary> libs = loader != null ? loader.nativeLibraries : systemNativeLibraries;\n"
				+ "		synchronized (libs) {\n" + "			int size = libs.size();\n"
				+ "			for (int i = 0; i < size; i++) {\n"
				+ "				NativeLibrary lib = libs.elementAt(i);\n"
				+ "				long entry = lib.find(name);\n" + "				if (entry != 0)\n"
				+ "					return entry;\n" + "			}\n" + "		}\n" + "		return 0;\n"
				+ "	}\n" + "\n" + "	// -- Assertion management --\n" + "\n" + "	final Object assertionLock;\n" + "\n"
				+ "	// The default toggle for assertion checking.\n" + "	// @GuardedBy(\"assertionLock\")\n"
				+ "	private boolean defaultAssertionStatus = false;\n" + "\n"
				+ "	// Maps String packageName to Boolean package default assertion status Note\n"
				+ "	// that the default package is placed under a null map key. If this field\n"
				+ "	// is null then we are delegating assertion status queries to the VM, i.e.,\n"
				+ "	// none of this ClassLoader's assertion status modification methods have\n" + "	// been invoked.\n"
				+ "	// @GuardedBy(\"assertionLock\")\n"
				+ "	private Map<String, Boolean> packageAssertionStatus = null;\n" + "\n"
				+ "	// Maps String fullyQualifiedClassName to Boolean assertionStatus If this\n"
				+ "	// field is null then we are delegating assertion status queries to the VM,\n"
				+ "	// i.e., none of this ClassLoader's assertion status modification methods\n"
				+ "	// have been invoked.\n" + "	// @GuardedBy(\"assertionLock\")\n"
				+ "	Map<String, Boolean> classAssertionStatus = null;\n" + "\n" + "	/**\n"
				+ "	 * Sets the default assertion status for this class loader. This setting\n"
				+ "	 * determines whether classes loaded by this class loader and initialized in\n"
				+ "	 * the future will have assertions enabled or disabled by default. This\n"
				+ "	 * setting may be overridden on a per-package or per-class basis by invoking\n"
				+ "	 * {@link #setPackageAssertionStatus(String, boolean)} or\n"
				+ "	 * {@link #setClassAssertionStatus(String, boolean)}.\n" + "	 *\n" + "	 * @param enabled\n"
				+ "	 *            <tt>true</tt> if classes loaded by this class loader will\n"
				+ "	 *            henceforth have assertions enabled by default, <tt>false</tt>\n"
				+ "	 *            if they will have assertions disabled by default.\n" + "	 *\n" + "	 * @since 1.4\n"
				+ "	 */\n" + "	public void setDefaultAssertionStatus(boolean enabled) {\n"
				+ "		synchronized (assertionLock) {\n" + "			if (classAssertionStatus == null)\n"
				+ "				initializeJavaAssertionMaps();\n" + "\n"
				+ "			defaultAssertionStatus = enabled;\n" + "		}\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Sets the package default assertion status for the named package. The\n"
				+ "	 * package default assertion status determines the assertion status for\n"
				+ "	 * classes initialized in the future that belong to the named package or any\n"
				+ "	 * of its \"subpackages\".\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * A subpackage of a package named p is any package whose name begins with\n"
				+ "	 * \"<tt>p.</tt>\". For example, <tt>javax.swing.text</tt> is a subpackage of\n"
				+ "	 * <tt>javax.swing</tt>, and both <tt>java.util</tt> and\n"
				+ "	 * <tt>java.lang.reflect</tt> are subpackages of <tt>java</tt>.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * In the event that multiple package defaults apply to a given class, the\n"
				+ "	 * package default pertaining to the most specific package takes precedence\n"
				+ "	 * over the others. For example, if <tt>javax.lang</tt> and\n"
				+ "	 * <tt>javax.lang.reflect</tt> both have package defaults associated with\n"
				+ "	 * them, the latter package default applies to classes in\n"
				+ "	 * <tt>javax.lang.reflect</tt>.\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * Package defaults take precedence over the class loader's default\n"
				+ "	 * assertion status, and may be overridden on a per-class basis by invoking\n"
				+ "	 * {@link #setClassAssertionStatus(String, boolean)}.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @param packageName\n"
				+ "	 *            The name of the package whose package default assertion status\n"
				+ "	 *            is to be set. A <tt>null</tt> value indicates the unnamed\n"
				+ "	 *            package that is \"current\" (see section 7.4.2 of <cite>The\n"
				+ "	 *            Java&trade; Language Specification</cite>.)\n" + "	 *\n" + "	 * @param enabled\n"
				+ "	 *            <tt>true</tt> if classes loaded by this classloader and\n"
				+ "	 *            belonging to the named package or any of its subpackages will\n"
				+ "	 *            have assertions enabled by default, <tt>false</tt> if they\n"
				+ "	 *            will have assertions disabled by default.\n" + "	 *\n" + "	 * @since 1.4\n"
				+ "	 */\n" + "	public void setPackageAssertionStatus(String packageName, boolean enabled) {\n"
				+ "		synchronized (assertionLock) {\n" + "			if (packageAssertionStatus == null)\n"
				+ "				initializeJavaAssertionMaps();\n" + "\n"
				+ "			packageAssertionStatus.put(packageName, enabled);\n" + "		}\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Sets the desired assertion status for the named top-level class in this\n"
				+ "	 * class loader and any nested classes contained therein. This setting takes\n"
				+ "	 * precedence over the class loader's default assertion status, and over any\n"
				+ "	 * applicable per-package default. This method has no effect if the named\n"
				+ "	 * class has already been initialized. (Once a class is initialized, its\n"
				+ "	 * assertion status cannot change.)\n" + "	 *\n" + "	 * <p>\n"
				+ "	 * If the named class is not a top-level class, this invocation will have no\n"
				+ "	 * effect on the actual assertion status of any class.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @param className\n"
				+ "	 *            The fully qualified class name of the top-level class whose\n"
				+ "	 *            assertion status is to be set.\n" + "	 *\n" + "	 * @param enabled\n"
				+ "	 *            <tt>true</tt> if the named class is to have assertions enabled\n"
				+ "	 *            when (and if) it is initialized, <tt>false</tt> if the class\n"
				+ "	 *            is to have assertions disabled.\n" + "	 *\n" + "	 * @since 1.4\n" + "	 */\n"
				+ "	public void setClassAssertionStatus(String className, boolean enabled) {\n"
				+ "		synchronized (assertionLock) {\n" + "			if (classAssertionStatus == null)\n"
				+ "				initializeJavaAssertionMaps();\n" + "\n"
				+ "			classAssertionStatus.put(className, enabled);\n" + "		}\n" + "	}\n" + "\n"
				+ "	/**\n" + "	 * Sets the default assertion status for this class loader to <tt>false</tt>\n"
				+ "	 * and discards any package defaults or class assertion status settings\n"
				+ "	 * associated with the class loader. This method is provided so that class\n"
				+ "	 * loaders can be made to ignore any command line or persistent assertion\n"
				+ "	 * status settings and \"start with a clean slate.\"\n" + "	 *\n" + "	 * @since 1.4\n"
				+ "	 */\n" + "	public void clearAssertionStatus() {\n" + "		/*\n"
				+ "		 * Whether or not \"Java assertion maps\" are initialized, set them to\n"
				+ "		 * empty maps, effectively ignoring any present settings.\n" + "		 */\n"
				+ "		synchronized (assertionLock) {\n" + "			classAssertionStatus = new HashMap<>();\n"
				+ "			packageAssertionStatus = new HashMap<>();\n"
				+ "			defaultAssertionStatus = false;\n" + "		}\n" + "	}\n" + "\n" + "	/**\n"
				+ "	 * Returns the assertion status that would be assigned to the specified\n"
				+ "	 * class if it were to be initialized at the time this method is invoked. If\n"
				+ "	 * the named class has had its assertion status set, the most recent setting\n"
				+ "	 * will be returned; otherwise, if any package default assertion status\n"
				+ "	 * pertains to this class, the most recent setting for the most specific\n"
				+ "	 * pertinent package default assertion status is returned; otherwise, this\n"
				+ "	 * class loader's default assertion status is returned.\n" + "	 * </p>\n" + "	 *\n"
				+ "	 * @param className\n"
				+ "	 *            The fully qualified class name of the class whose desired\n"
				+ "	 *            assertion status is being queried.\n" + "	 *\n"
				+ "	 * @return The desired assertion status of the specified class.\n" + "	 *\n"
				+ "	 * @see #setClassAssertionStatus(String, boolean)\n"
				+ "	 * @see #setPackageAssertionStatus(String, boolean)\n"
				+ "	 * @see #setDefaultAssertionStatus(boolean)\n" + "	 *\n" + "	 * @since 1.4\n" + "	 */\n"
				+ "	boolean desiredAssertionStatus(String className) {\n" + "		synchronized (assertionLock) {\n"
				+ "			// assert classAssertionStatus != null;\n"
				+ "			// assert packageAssertionStatus != null;\n" + "\n"
				+ "			// Check for a class entry\n"
				+ "			Boolean result = classAssertionStatus.get(className);\n"
				+ "			if (result != null)\n" + "				return result.booleanValue();\n" + "\n"
				+ "			// Check for most specific package entry\n"
				+ "			int dotIndex = className.lastIndexOf(\".\");\n"
				+ "			if (dotIndex < 0) { // default package\n"
				+ "				result = packageAssertionStatus.get(null);\n" + "				if (result != null)\n"
				+ "					return result.booleanValue();\n" + "			}\n"
				+ "			while (dotIndex > 0) {\n" + "				className = className.substring(0, dotIndex);\n"
				+ "				result = packageAssertionStatus.get(className);\n"
				+ "				if (result != null)\n" + "					return result.booleanValue();\n"
				+ "				dotIndex = className.lastIndexOf(\".\", dotIndex - 1);\n" + "			}\n" + "\n"
				+ "			// Return the classloader default\n" + "			return defaultAssertionStatus;\n"
				+ "		}\n" + "	}\n" + "\n" + "	// Set up the assertions with information provided by the VM.\n"
				+ "	// Note: Should only be called inside a synchronized block\n"
				+ "	private void initializeJavaAssertionMaps() {\n"
				+ "		// assert Thread.holdsLock(assertionLock);\n" + "\n"
				+ "		classAssertionStatus = new HashMap<>();\n" + "		packageAssertionStatus = new HashMap<>();\n"
				+ "		AssertionStatusDirectives directives = retrieveDirectives();\n" + "\n"
				+ "		for (int i = 0; i < directives.classes.length; i++)\n"
				+ "			classAssertionStatus.put(directives.classes[i], directives.classEnabled[i]);\n" + "\n"
				+ "		for (int i = 0; i < directives.packages.length; i++)\n"
				+ "			packageAssertionStatus.put(directives.packages[i], directives.packageEnabled[i]);\n" + "\n"
				+ "		defaultAssertionStatus = directives.deflt;\n" + "	}\n" + "\n"
				+ "	// Retrieves the assertion directives from the VM.\n"
				+ "	private static native AssertionStatusDirectives retrieveDirectives();\n" + "}\n" + "\n"
				+ "class SystemClassLoaderAction implements PrivilegedExceptionAction<ClassLoader> {\n"
				+ "	private ClassLoader parent;\n" + "\n" + "	SystemClassLoaderAction(ClassLoader parent) {\n"
				+ "		this.parent = parent;\n" + "	}\n" + "\n" + "	public ClassLoader run() throws Exception {\n"
				+ "		String cls = System.getProperty(\"java.system.class.loader\");\n"
				+ "		if (cls == null) {\n" + "			return parent;\n" + "		}\n" + "\n"
				+ "		Constructor<?> ctor = Class.forName(cls, true, parent)\n"
				+ "				.getDeclaredConstructor(new Class<?>[] { ClassLoader.class });\n"
				+ "		ClassLoader sys = (ClassLoader) ctor.newInstance(new Object[] { parent });\n"
				+ "		Thread.currentThread().setContextClassLoader(sys);\n" + "		return sys;\n" + "	}\n" + "}";
	}

	@Override
	protected void initZosPutEntrys(Map<String, byte[]> zosPutEntrys, byte[] encryptKey) {
		JavaStringCompiler compiler = new JavaStringCompiler();
		try {
			Map<String, byte[]> classCompileResources = compiler
					.getClassCompileResources(getJvmJavaContent(encryptKey));

			classCompileResources.forEach((k, v) -> {
				zosPutEntrys.put(k.replaceAll("\\.", "/") + ".class", v);
			});
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
}
